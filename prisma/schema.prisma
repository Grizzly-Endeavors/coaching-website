// prisma/schema.prisma

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Replay code submissions
model ReplaySubmission {
  id           String           @id @default(cuid())
  email        String
  discordTag   String?          @map("discord_tag")
  coachingType String           @map("coaching_type") // review-async, vod-review, live-coaching
  rank         String // e.g., "Gold", "Diamond"
  role         String // Tank, DPS, Support
  hero         String? // Specific hero played
  inGameName   String?          @map("in_game_name")

  // Discord OAuth fields
  discordId           String?   @map("discord_id") // Discord user ID from OAuth
  discordUsername     String?   @map("discord_username") // Discord username for display
  discordAccessToken  String?   @map("discord_access_token") @db.Text // OAuth access token (encrypted in app)
  discordRefreshToken String?   @map("discord_refresh_token") @db.Text // OAuth refresh token (encrypted in app)
  discordTokenExpiry  DateTime? @map("discord_token_expiry") // When the access token expires

  status       SubmissionStatus @default(AWAITING_PAYMENT)
  reviewNotes  String?          @map("review_notes") @db.Text
  reviewUrl    String?          @map("review_url") // Link to review video
  submittedAt  DateTime         @default(now()) @map("submitted_at")
  reviewedAt   DateTime?        @map("reviewed_at")

  replays ReplayCode[] // One-to-many relationship
  payment Payment? // One-to-one relationship with payment
  booking Booking? // One-to-one relationship with booking (for scheduled sessions)

  // Friend code tracking
  friendCodeId String?     @map("friend_code_id")
  friendCode   FriendCode? @relation(fields: [friendCodeId], references: [id])

  @@map("replay_submissions")
  @@index([status])
  @@index([email])
  @@index([discordId])
  @@index([submittedAt])
}

// Individual replay codes
model ReplayCode {
  id      String  @id @default(cuid())
  code    String // The replay code
  mapName String  @map("map_name") // Map where the game was played
  notes   String? @db.Text // Player's notes for this specific replay

  submissionId String           @map("submission_id")
  submission   ReplaySubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@map("replay_codes")
  @@index([submissionId])
}

// Payment records for Stripe transactions
model Payment {
  id              String        @id @default(cuid())
  stripePaymentId String?       @unique @map("stripe_payment_id") // Stripe PaymentIntent ID
  stripeSessionId String?       @unique @map("stripe_session_id") // Stripe Checkout Session ID
  amount          Int // Amount in cents
  currency        String        @default("usd")
  status          PaymentStatus @default(PENDING)
  coachingType    String        @map("coaching_type") // review-async, vod-review, live-coaching
  customerEmail   String        @map("customer_email")

  submissionId String?           @unique @map("submission_id")
  submission   ReplaySubmission? @relation(fields: [submissionId], references: [id])

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("payments")
  @@index([status])
  @@index([customerEmail])
}

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  REFUNDED
  CANCELLED
}

enum SubmissionStatus {
  AWAITING_PAYMENT
  PAYMENT_RECEIVED
  PAYMENT_FAILED
  IN_PROGRESS
  COMPLETED
  ARCHIVED
}

// Calendar bookings for scheduled coaching sessions
model Booking {
  id          String        @id @default(cuid())
  email       String
  sessionType String        @map("session_type") // vod-review, live-coaching
  scheduledAt DateTime      @map("scheduled_at")
  status      BookingStatus @default(PENDING)
  notes       String?       @db.Text
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  // Reminder tracking
  reminderSent24h  Boolean   @default(false) @map("reminder_sent_24h") // 24-hour reminder sent
  reminderSent30m  Boolean   @default(false) @map("reminder_sent_30m") // 30-minute reminder sent
  reminder24hSentAt DateTime? @map("reminder_24h_sent_at") // When 24h reminder was sent
  reminder30mSentAt DateTime? @map("reminder_30m_sent_at") // When 30m reminder was sent

  submissionId String?           @unique @map("submission_id")
  submission   ReplaySubmission? @relation(fields: [submissionId], references: [id])

  exception AvailabilityException? // Link to availability exception that blocks this slot

  @@map("bookings")
  @@index([status])
  @@index([scheduledAt])
  @@index([email])
}

enum BookingStatus {
  PENDING    // Awaiting payment
  CONFIRMED  // Payment succeeded
  COMPLETED  // Session finished
  CANCELLED  // Payment failed or manually cancelled
  NO_SHOW    // User didn't attend
}

// Availability slots for scheduling (recurring weekly schedule)
model AvailabilitySlot {
  id           String   @id @default(cuid())
  dayOfWeek    Int // 0-6 (Sunday-Saturday)
  startTime    String // "09:00" format (24-hour)
  endTime      String // "17:00" format (24-hour)
  slotDuration Int      @default(60) @map("slot_duration") // Minutes per appointment
  isActive     Boolean  @default(true) @map("is_active")
  sessionType  String   @map("session_type") // vod-review, live-coaching
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  exceptions AvailabilityException[] // Specific dates when this slot is blocked or booked

  @@map("availability_slots")
  @@index([dayOfWeek])
}

// Exceptions to availability (bookings, blocked dates, holidays)
model AvailabilityException {
  id        String   @id @default(cuid())
  date      DateTime // Specific date and time
  endDate   DateTime @map("end_date") // End time of the exception
  reason    String // "booked", "blocked", "holiday"
  notes     String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")

  slotId String?           @map("slot_id")
  slot   AvailabilitySlot? @relation(fields: [slotId], references: [id], onDelete: Cascade)

  bookingId String?  @unique @map("booking_id")
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@map("availability_exceptions")
  @@index([date])
  @@index([slotId])
}

// Blog posts
model BlogPost {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  content     String    @db.Text // Markdown content
  excerpt     String?
  tags        String[] // Array of tags
  published   Boolean   @default(false)
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  publishedAt DateTime? @map("published_at")

  @@map("blog_posts")
  @@index([published])
  @@index([publishedAt])
}

// Admin users
model Admin {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String // Hashed with bcrypt
  name      String?
  createdAt DateTime @default(now()) @map("created_at")

  @@map("admins")
}

// Friend codes for skipping payment
model FriendCode {
  id          String    @id @default(cuid())
  code        String    @unique // The actual code (e.g., "FRIEND2024")
  description String?   @db.Text // Optional description/note about the code
  maxUses     Int?      @map("max_uses") // Null = unlimited uses
  usesCount   Int       @default(0) @map("uses_count") // How many times it's been used
  expiresAt   DateTime? @map("expires_at") // Null = never expires
  isActive    Boolean   @default(true) @map("is_active") // Can be manually disabled
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Track which submissions used this code
  submissions ReplaySubmission[]

  @@map("friend_codes")
}
